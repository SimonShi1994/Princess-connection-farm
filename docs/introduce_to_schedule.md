# Schedule 计划 使用帮助

: 2020-08-31 By TheAutumnOfRice：增加了Schedule总览部分  
: 2020-09-04 By TheAutumnOfRice: 增加了启动脚本的部分和自启动配置

目录

- 1 Schedule总览
  - 1.1 创建用户
  - 1.2 创建用户组
  - 1.3 创建任务
  - 1.4 创建批配置
  - 1.5 创建计划
- 2 启动脚本
  - 2.1 基本组件
  - 2.2 “谁做什么”指令
  - 2.3 绑定Schedule
  - 2.4 报错处理
  - 2.5 命令运行
- 3 配置文件
  - 3.1 配置Server Chan （待完善）
  - 3.2 配置OCR （待完善）
  - 3.3 配置模拟器自动控制
  - 3.4 配置自动关机

## 1. Schedule总览

一款只能执行特定任务脚本不是一个好脚本。一款优秀的脚本，可以方便地指派某些账号去做某些任务，甚至可以方便地指定一个“计划”，在“账号做
任务”的基础上，增加“什么时候账号做任务”的功能。在本脚本中，schedule系统就实现了以上功能。

### 1.1 创建用户

一个用户，被称为`user`，具有用户名和密码两条基本属性，它可以在控制台中通过`user`族命令创建。这是执行计划的最基本元素之一，请首先
买30~40个小号，然后将它们创建吧！

不妨假设，我们想要执行单公会的小号送mana功能，那么我们需要首先准备一个大号，5个装备号，外加24个mana号。也就是说，我们一共有30个号。
每一个号，都有一个对应的账号和密码。在main_new.py的同一目录下创建一个`zhanghao.txt`的文本文件，在里面按照“用户 （空格） 密码“的形式把三十行号
输进去吧！（实际使用时请将“dahao”替换成你大号的账号，“dahao_pwd”替换为你大号的密码，其它同理哦。

```
dahao dahao_pwd
zhuangbei1 zhaungbei1_pwd
...
zhuangbei5 zhuangbei5_pwd
mana1 mana1_pwd
...
mana24 mana24_pwd
```

接下来，使用`python main_new.py`打开控制台，输入`edit`进入配置编辑模式，再输入以下指令从文件中导入用户：

```
user -c -file zhanghao.txt 
```

注：可以输入`user?`命令查看更多关于用户的操作方式。

此时，我们的用户就创建好啦，在控制台输入`user -l`查看下效果吧，屏幕上将显示30行的账号XXXX加载完成。
被加载的用户会以json的形式存储在`/users`文件夹中，可以进入查看，我们将看到有30个文件名为用户名的文本文件，随便点开一个，观察到
用户名和密码已经输入完毕。

### 1.2 创建用户组

一个用户组，被称作`group`。很多时候，我们需要对很多账号做同样的操作，如果输入类似如下的命令，就会非常麻烦：

```
装备号1 做 捐装备
装备号2 做 捐装备
装备号3 做 捐装备
装备号4 做 捐装备
装备号5 做 捐装备
```

我们希望可以输入`全部装备号 做 捐装备`类似的命令方式，就可以实现上面的效果。因此，我们需要把这种号全部编组。

首先，我们在根目录下（与main_new.py同一目录）创建一个文件夹`/groups`，在其中新建一个文本文件，文件名为`zhuangbei.txt`。
虽然理论上支持中文，不过为了保险起见，尽量全部使用字母吧。创建完成后，我们在其中写五行，每行一个账号名：

```
zhuangbei1
zhuangbei2
zhuangbei3
zhuangbei4
zhuangbei5
```

这样，我们就建了一个名叫`zhuangbei`的组，在配置控制台中，输入`group -l`，将会查看到刚刚创建的组的信息。
还可以通过`group zhuangbei`命令，查看zhuangbei组内的成员。如果没有产生错误，说明这个组已经建立成功啦。

同理，我们建立一个`mana`的组，并且把24个mana号的账号写入文件，使用`group mana`命令确认组创建成功。

### 1.3 创建任务

任务，`task`，是用户自定义的，一串子脚本的列表。比如，一个mana的脚本顺序可能包含以下流程：

行会点赞 -> 地下城借人 -> 刷1-1拿经验

定义好这样的task后，我们就可以告诉脚本`mana组执行mana脚本`来执行既定的计划啦。

首先，进入配置控制台，通过`task -c mana`命令，创建一个名字为mana的任务。
然后，用`task -e mana`命令，进入mana任务的编辑模式。在编辑模式中，你可以随时输入`help`查看使用帮助。

第一个要添加的任务是行会点赞，这是一个行会相关的任务。查看help得知，查看所有行会相关的任务代码，需要使用`list -h`命令。
在控制台输入该命令，查找发现行会点赞的命令缩写是`h6`。

接下来，我们添加这个命令。在控制台输入`add h6`，进入行会点赞的添加流程。很多命令有具体的实现细节，我们只需要跟着命令行提示
一步一步进行即可。此时，命令行提示我们输入一个0或1的整数，我们想给战力最高的人点赞，于是这里输入1然后回车。

这样，第一个任务就创建完毕了。可以输入`show`命令，发现刚刚创建的任务已经添加成功了。
注意，此时任务还属于未保存的状态，如果需要保存任务，必须输入`save`。及时保存是好习惯哦。

用同样的方法，把剩下两个子任务依次添加进mana中。然后，`save`,`exit`，至此一个mana号的任务就创建完毕了。

任务文件被保存在`/tasks`文件夹下，我们将找到之前定义的`mana.txt`文件，点进查看。该任务通过json的方式存储，其中用
`type`关键字表示该任务的缩写，而其余的均为该任务的参数。目前的控制台不能很好地做到任务的编辑，如果需要编辑任务的参数，
可以手动打开task文件，然后调换顺序，修改参数等。修改结束后，建议先在控制台中输入`task mana`命令查看该任务的详情，检查
编辑情况，若弹出错误，则说明该任务文件非法，按照提示修改即可。

同理，创建完mana任务后，再接着创建一个捐赠装备的juanzeng任务吧！至于大号的任务，这里先不赘述，将在介绍完schedule后进一步介绍。

目前为止，我们已经成功创建了用户、组与任务。此时，我们已经可以通过“谁干谁”来执行一条指令了，具体使用方法见2.2.

### 1.4 创建批配置

批，`batch`，如字面意思，为一批任务的集合。在这之前，我们已经定义了`user`,`group`,`task`。现在，我们需要一个“谁做谁”的方法，
指定谁做谁的方法文件就是`batch`。

在一个batch中，我们可以只指定某user执行某task，也可以指定user1执行task1，user2执行task2，也可以执行user1执行task1，group1执行taskgroup……
比如，我们可能希望写一个做日常任务的脚本，大号的日常任务和小号的日常任务不同，那么我们可以写一个`batch`，在里面指定大号做
大号的日常，小号做小号的日常。这样，我们只要执行这个batch，一系列“谁做谁”的任务就进入任务队列啦。

不过，即使是这样，我们还会不满意。因为，也许我们希望脚本在一堆日常任务中，优先执行大号的日常任务，而小号的日常任务需求不大，可以延后
执行。所以，我们还可以在一个batch中对每一个子任务指定优先级`priority`。优先级默认为0，高优先级的任务将优先执行。

在1.3中，我们已经创建了mana任务和zhuangbei任务。一般而言，装备捐赠和mana任务应该是独立的。因为它们的触发条件不同。捐赠mana应该在
大号放上支援后进行，每天只进行一次；而装备任务是在大号发起装备捐赠后执行，每天可执行三次。关于执行条件的制定和24h挂机，将在schedule中介绍。
此处，我们先创建两个独立的batch，每个batch中只有一条“谁做谁”的任务，即我们可以创建批”zhuangbei“，里面写上”装备号执行捐赠装备“；
再创建批”mana“，里面写上”mana号执行捐赠mana“。

以上都是思路，具体操作如下。首先，在配置控制台中，输入`batch -c zhuangbei`创建一个装备号的`batch`。
然后，输入`batch -e zhuangbei`进入该batch的编辑模式。输入`help`可以查看详细帮助。

此处，让我们添加一个”装备号捐装备“的子任务吧！由于之前已经创建了名为`zhuangbei`的`group`以及名为`zhuangbei`的`task`。
于是只需要输入`add -g zhuangbei zhuangbei`即可。输入`show`查看结果，然后`save`，`exit`，完成一次创建。

在目录`/batches`中可以看到我们之前建立的批配置，点进去查看一下，发现录入成功了。

同理，继续创建一个名为`mana`的”玛娜号执行捐赠mana“的batch吧！

### 1.5 创建计划

计划，`schedule`，为上述四元素的最高层控制信息。`batch`通过控制user或group与task的关系实现了”谁干什么“，但有很多个batch的时候，
我们执行哪一个呢？什么时候执行什么batch呢？这些都要交给schedule来处理了。

schedule能干的事情有很多。如，希望一个号早上、晚上执行不同的batch，那么可以通过设置条件为”指定时间段启动“；或者希望大号一日三捐，想自动捐赠，
那么可以通过设置条件为“可以捐赠时启动”。如果想执行40to1，那么它需要六个batch依次执行
（公会1小号捐赠->公会1会长踢大号->大号加入公会2->公会2小号捐赠->公会2会长踢大号->大号加入公会1），类似这种依次执行batch的需求也可以在
schedule中实现。

此处，我们只介绍最简单的功能，熟悉创建计划的流程。接下来，我们先创建一个捐赠装备的schedule。该schedule没有任何条件，它包含的信息仅仅是：
当该schedule被执行时，立刻执行juanzeng的batch。

首先，在控制台中输入`schedule -c zhuangbei`，创建一个名为zhuangbei的计划。然后输入`schedule -e zhuangbei`，进入编辑模式。

输入help，可以发现，有三种类型的子计划可以创建。`asap`计划为立即执行的计划。该计划意思是：如果满足条件，则立即执行，否则该计划将被跳过。
`wait`计划为等待执行计划，该计划意思是：如果满足条件，则立即执行，否则程序将一直运行直到触发条件位置。`config`为对整个计划的其它配置。

比如，我有两个batch，分别为上午任务与晚上任务。如果都设置为asap，那么如果上午运行程序，晚上任务将会被跳过，执行上午脚本结束后脚本将退出。
如果都设置为wait，那么如果上午运行程序，晚上任务会进入“等待执行”状态，执行上午脚本结束后，脚本不会退出，将一直等待执行到下午脚本执行完毕为止。
一般来说，如果要设置24小时挂机，那么wait是一个良好的选择；如果仅仅是希望执行一次性的任务，那么也可以使用asap。

此处，我们创建的zhuangbei为一个一次性的任务，输入`add asap`，进入配置引导。首先给这个子任务起一个名字，不妨叫zhuangbei。
目前，假设我们希望大号是手动操作，发起捐赠后，手动执行小号的捐赠脚本，那么该子计划就只包含一个批，即前面已经创建的zhuangbei，此处输入0。
如果希望大号自动发起捐赠，则可以再写一个大号发起捐赠的batch，然后依次执行大号发起捐赠与小号捐装备的batch，此处就应该输入1。

简单起见，此处我们采用第一种方案，输入0。然后，输入zhuangbei，这是之前写好的批配置文件。我们不需要任何条件，输入0退出设置。关于记录方面，
也不需要特殊设置，选择默认的0，正常运行即可。此时，我们就成功创建了一个子计划，输入`show`查看当前的计划情况，可以发现，我们已经在
名为zhuangbei的计划中，建立了名叫zhuangbei的子计划，该子计划为立即执行，将执行名为zhuangbei的批配置。该批配置的内容为让组zhuangbei中的
全部号执行名为zhuangbei的task。

创建完毕，输入`save`，`exit`。此时，user,group,task,batch,schedule，从最初的用户到最终的计划，我们终于完成了一个计划的配置全流程。

schedule文件保存在`/schedules`中，同样，可以进入查看，并且进行修改等操作。

同样，我们可以再创建另一个名为mana的计划，用来立即执行名为mana的batch。

## 2. 启动脚本

在第一节中，我们已经熟悉了五种不同元素的含义以及创建方法，接下来就到运行脚本的时候了。

### 2.1 基本组件

本节介绍脚本运行时的几个基本组件，以及它们之间的调用关系。

一个最小的执行脚本的单元叫做设备`Device`。每个设备具有唯一的串口`Serial`，作为和模拟器交互的通道。当启动模拟器后（以雷电为例），输入adb
指令`adb devices`，将显示如下输出：

```
List of devices attached
emulator-5554   device
emulator-5556   device
```

其中，左侧"emulator-5554","emulator-5556"就是串口。脚本正是通过这些Serial得以与模拟器通信，达到自动控制的目的。

如果模拟器未启动，或者adb连接失败时，设备的状态显示为“离线”。当模拟器启动，对应串口存在时，设备处于唤醒状态。一个唤醒状态的设备
可以接收一条“谁做什么”的指令，此时该设备进入工作状态，并且按照既定的脚本控制模拟器完成相应的任务。任务完成后，该设备重新回到空闲的状态。

控制所有的`Device`，进行任务调度（指派某一个Device进行某一项任务）的类叫做`PCRInitializer`，其任务调度的核心是一个优先级队列。
当一系列含有优先级的指令（谁做什么）传入后，PCRInitializer会按优先级从高到低的顺序依次指派空闲的Device来执行这些指令。

而最高层的`Schedule`，则是一个自动向`PCRInitializer`中添加任务的方法。它按照既定的计划，把满足条件的任务加入到`PCRInitializer`的
优先级队列中，达到24小时自动控制的目的。

### 2.2 “谁做什么”指令

假设我们没有创建具体的Schedule，但依然可以通过向`PCRInitializer`发送一条“谁做什么”的指令来执行脚本。

输入`python main_new.py`启动脚本，输入help查看帮助。此时我们并没有绑定计划，可以看到命令`first`的解释是：
启动脚本，此后可以输入指令添加计划。输入first，注意到我们启动了一个名叫`__schedule_free__`的Schedule，
该计划为自动生成的空计划，不含任何控制信息。

输入help，查看实时控制帮助。`device`命令可以查看当前每个连接设备的状态，而`queue`命令可以查看当前优先级队列的情况。
不妨假设我们之前已经创建了名为zhuangbei的group，以及一个名为zhuangbei的task，现在想让装备号执行捐赠装备的操作，
只需要在控制台中输入`first -g zhuangbei zhuangbei`即可。输入`queue`显示任务队列，观察到一批任务已经添加到
队列中了。

手动向队列中添加任务的方法有三种。第一种是指定用户执行任务，第二种是指定组执行任务，第三种直接执行一个写好的batch。
如果使用first命令，则会清除之前的运行记录重新运行；如果使用continue命令，则会从上次中断的地方继续运行。**注意：如果任务发生
更改，必须使用first命令重新进行，否则会产生运行记录冲突的问题。**

### 2.3 绑定Schedule

每次都手动输入指令非常不方便，而且也无法达到24h执行的效果。因此，通常我们需要写一个schedule来辅助任务的执行。以一个
名为zhuangbei的Schedule为例，首先，输入`bind zhuangbei`命令，将该计划与控制台绑定。

绑定之后，输入help查看帮助，会发现在原来的基础上，增加了很多其它的选项。输入first或者continue，即可执行该计划。
绑定的Schedule会存放在`/bind_schedule.txt`中，因此绑定一次后，每次重新打开控制台都无需再次绑定。

在config.ini中，有一个名为running_input的选项，默认设置的是False，表示在运行时不允许用户输入指令。事实上，
在运行的命令行中追加输入指令是不妥的做法，且有小概率导致子进程卡死。在没有绑定schedule时，实时控制是必要的，因此
被强制开启。如果有需要在schedule运行的同时可以追加新的任务到任务队列，可以在config.ini中将该项设置为True。
也可以在实时控制中输入join让主进程进入等待状态。

### 2.4 报错处理

如果脚本运行中遇到错误，出错的账号将无法继续运行，即使使用first或者restart命令也没有用。这是因为出现的错误很可能是脚本的BUG，所以一定要
人为处理或者进行错误的上报。出错的账号及任务会显示在state中，在`/log`文件夹下能找到对应的日志（`遗书`)，在`/error_screenshot`文件夹下能找到
脚本崩溃前最后一张截图的存档（`遗照`）。欢迎将遗书与遗照反馈给开发者，以便脚本更好的发展！

错误解决后，想要恢复脚本的运行，只需要输入`clear -all`即可，它将清除zhuangbei计划中所有子计划的错误信息，此时再continue，就能继续跑脚本了。

### 2.5 命令运行

如果直接使用`python main_new.py`启动，则会进入控制台界面，但是还需要人为输入控制指令，比较麻烦。

我们为其提供了执行某一个schedule的控制参数，方法为`python main_new.py first (schedulename)`，用来重新跑一个名称为
schedulename的计划。也可以把first改成continue，此时从上次中断的地方回复。该启动方法适合使用任务计划进行自启动的用户。

## 3. 配置文件

在根目录下，有一个config.ini的配置文件，通过修改配置文件可以获得更多的拓展功能，从而得到更好的使用体验。在控制台中输入info可以查看
当前全部的配置情况。

### 3.1 配置Server Chan

待补充 @CyiceK

### 3.2 配置OCR

待补充 
@CyiceK 关于OCR模式和baiduAPI
@MomentDerek 关于本地OCR使用方法

### 3.3 配置模拟器自动控制

本节的内容介绍如何配置模拟器自动控制，以达成让脚本自动在执行任务时唤醒模拟器，在闲置时关闭模拟器，以及在模拟器卡死时自动重启模拟器。
配置模拟器自动控制将使家庭电脑上24小时执行成为可能。

目前版本暂时只支持雷电模拟器的自动控制，这是因为雷电官方提供了模拟器控制的API。如果有其它模拟器的控制需求，欢迎进群交流补充。

进入config.ini，首先确保`selected_emulator`的值为要控制的模拟器的名称：雷电。

接下来，在`emulator_console`中填写雷电模拟器控制器所在路径，该文件名称为`ldconsole.exe`，如果没有该文件，可能是雷电版本
较低导致，请更新雷电的版本后继续使用.

在雷电模拟器的多开界面，第一列可以看到每一个模拟器的ID，它从0开始编号，分别为0，1，2，……。在`emulator_id`中填入一个列表，
每个元素为整数类型，表示编号。如`[0,1,2]`，表示需要多开的模拟器编号为0，1，2号。

注：笔者在使用中发现，0号机（serial="emulator-5554") 有小概率出现莫名其妙无法连接的状况，所以有条件可以多创建一个副本，跳过0号
进行多开，只需把`emulator_id`设置为从1开始即可，如`[1,2,3]`

脚本实现自动控制的前提是保证模拟器编号和串口号一一对应，所以需要事先进行确认。在`emulator_console`未设置的情况下，
打开所有准备多开的模拟器，然后运行任意Schedule（空的也行）。这会检测所有连接的模拟器，并在所有没有安装ATX的模拟器上安装必要
的ATX插件。自动安装ATX的操作在自动启动模拟器时并不会执行。或者可以手动进行ATX的安装，只需要在运行窗口输入`uiautomator2 init`即可。

接着，如果`running_input`配置打开，可以在控制台输入device查看所有连接的设备的串口信息。如果所有雷电设备的USB调试打开，且合理配置
网卡的情况下，雷电的设备ID与其串口应该呈现如下对应关系：

```
ID 0：emulator-5554
ID 1：emulator-5556
ID 2：emulator-5558
......
```

如果不愿意在控制台输入device，也可以使用adb的命令查看设备信息，使用`adb devices`查看列出的串口即可。

若对应关系如上所示，即编号为x的模拟器串口为emulator-(5554+2x)，则我们不用进行任何多余的配置，只需让config.ini中
`auto_emulator_address`配置保留默认值的True，则脚本会通过上述公式自动换算串口名称。

当然，不排除有异常情况，对于配置不正常的雷电，有可能其对应关系如下所示：

```
ID 0：emulator-5554
ID 1：127.0.0.1:5557
ID 2：127.0.0.1:5559
......
```

此时，我们无法使用通用换算公式，必须手动将`auto_emulator_address`设置为False，然后在`emulator_address`中手动填写
显示的串口号。例如我们需要三开0，1，2号机，那对于上述例子，需要在`emulator_address`中填写`["emulator-5554",
"127.0.0.1:5557","127.0.0.1:5559]`。

此时，我们就完成了对雷电模拟器自动控制的配置，最后，我们可以设置是否在闲置时关闭模拟器（`quit_emulator_when_free`），推荐保留
默认的True。最大闲置时间（`max_free_time`）为一个设备处于空闲状态下最长的时间，超过该时间，该设备会将模拟器自动关闭，自身
进入离线状态，并等待下一个进入的任务将其激活。

好了，关闭全部模拟器，试试自启动吧！

### 3.4 配置自动关机

自动关机只会在`join`的状态下触发。所谓`join`，是一条实时控制的操作，它将主进程进入等待状态，直到全部任务完成。

如果`running_input`开启，可以在实时控制台中找到`join`和`join-shutdown`两种操作。前者等待任务全部完成后关闭脚本，而
后者在等待任务全部完成后关闭电脑（执行`shutdown -s -f -t 120`）。

注意到，这两条指令都可以追加 `-nowait` 参数。如果不用`-nowait`模式，则必须等到所有Schedule中的子任务都进入“执行完毕”状态，且
不会再度重启，此时才算一个Schedule的结束。这意味着，如果Schedule中存在restart配置（每日重置记录），或者有循环执行（record设置为2）的任务，
则使用join将导致程序永远运行，不会退出。

使用`-nowait`参数后，将忽略全部“等待执行”的子计划，只要检测到某一个状态，所有设备处于闲置或离线状态，且任务队列全空，即判定为执行结束。

如果想要全部任务执行完毕后关机，我们可以使用`join-shutdown`命令。不过注意到在`running_input`设置为False的情况下，我们无法通过实时控制台
输入指令。此时，我们可以通过修改config.ini中的`end_shutdown`参数来控制是否在运行结束后自动关机。如果设置为True，相当于在Schedule开始后
执行了`join-shutdown`命令；如果设置为False，则相当于Schedule开始后执行了`join`命令。（以上两个命令均不含`-nowait`方法）

自动关机功通常可以和2.5节介绍的命令启动方法相结合使用。

# 敬请期待

以下功能已经可以实现，有能力者可以先行探索解决方案，帮助会陆续更新，敬请期待。

- [ ] 如何配置Server酱
- [ ] 如何配置OCR
- [x] 如何配置自动启动模拟器和闲置关闭模拟器
- [x] 如何配置运行结束后自动关机
- [ ] 40to1的Schedule编写教程
- [ ] 自动装备捐赠的Schedule编写教程
- [ ] 如何写一个24小时计划脚本
